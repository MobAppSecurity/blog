I"•;<p>Hello world!</p>

<p>In this post, we will cover some of key points and introduction for ARM 64 bit language that will act as a first step of your journey to become a savy ARM exploit developer. To make this area balance between programming and exploit, we will go fist talk about programming(Fundamental Concept) and the next post will be on how to spot a vulnerability in the program.</p>

<h2> Prerequisite </h2>

<ul>
  <li>
    <p>Programming language that we will used throughout the series is C and Assembly(for programming and fundamental concept), while python for exploitation. This means I expect that you at least have learn the baisc of programming language.</p>
  </li>
  <li>
    <p>All of the steps and execution done in the series are done inside kali-linux 64 bit ARM from Raspberry Foundation(Download from this <a href="https://www.offensive-security.com/kali-linux-arm-images/">link</a>) that installed in Raspberry Pi 3B with 1GB RAM and 32 GB sd card memory. However, if the process is getting more intense, I will use Raspberry Pi 4.</p>
  </li>
</ul>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/arm64_exploit_dev_1/arm_ch1_1.png" alt="SETUP_PREVIEW" height="300px" width="300px" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/arm64_exploit_dev_1/arm_ch1_2.png" alt="SETUP_PREVIEW" height="300px" width="500px" /></p>

<h2> Disclaimer </h2>
<p>I‚Äôm not an expert nor a tech savy, I‚Äôm just a simple guy who curious about everything. The real expert is the author who wrote this great books that I bought and reference it to write this series, please support them by buying the original copy of the book from official store:</p>

<ul>
  <li>
    <p>Beginner Guide to Explotation on ARM volume I and II by Billy Ellis <a href="https://zygosec.com/book.html">buy-book</a></p>
  </li>
  <li>
    <p>Programming with 64-Bit ARM Assembly Language by Stephen Smith <a href="https://www.amazon.co.uk/Programming-64-Bit-ARM-Assembly-Language/dp/1484258800/ref=sr_1_66?crid=1UTYFW76705AO&amp;dchild=1&amp;keywords=reverse+engineering&amp;qid=1597079609&amp;sprefix=reverse+engin%2Caps%2C148&amp;sr=8-66#reader_1484258800">buy-book</a></p>
  </li>
  <li>
    <p>Effective C: An Introduction to Professional C Programming by Robert C. Seacord <a href="https://www.amazon.co.uk/gp/product/1718501048?ref=ppx_pt2_dt_b_prod_image">buy-book</a></p>
  </li>
</ul>

<h2> What is ARM and Why Should Care About IT? </h2>

<p>Basically, ARM is just another CPU architecture used by computer device like Intel and PowerPC. The difference between ARM with other architecture is that it is based on RISC or Reduce Instruction Set Computer instruction, this means that it consume less resource, less silicon, less cycle, less cost while offering pretty good performance. This is obviously become a selling point for ARM that makes Apple used it to design iPod in early day.</p>

<p>From portable music player, ARM can now find in a low power based device(IoT) including in iPhone and Android phones. Thus, we can expect that ARM is going to be the next hot thing in computer world, not to mention with the emergence of M1 chip from Apple, learning its security implementation will make it more crucial for future security researchers.</p>

<p>I hope this could motivate you guys, to pursue knowledge in this area.</p>

<h2> Why 64-bit? </h2>

<p>You probably wonder why am I starting with 64-bit rather than 32-bit? its because the architecture is still new and not many website cover this material, thus I like to be one of the first who introduce ARM-64 bit security. Eventhough you start learning from 32-bit all the knowledge it‚Äôs transferable to 64 bit since there are no major differences between these two.</p>

<p>That‚Äôs it for the pep talk, let‚Äôs go into real deal! we will start by covering:</p>

<ul>
  <li>
    <p>ARM CPU Registers</p>
  </li>
  <li>
    <p>Writing Hello World in ARM assembly</p>
  </li>
  <li>
    <p>Debugging Assembly</p>
  </li>
  <li>
    <p>Compiling and analysing C in ARM</p>
  </li>
</ul>

<h2> ARM CPU Registers </h2>

<p>Under the hood, the data in our computer is not parsed nor operated in memory instead it store in CPU register for operation.</p>

<p>Why not just do it directly to the memory? because there will be loss of time if we try to do it in memory, since memory itself is a separate component for the CPU to go there. Thus, you can think register as a component within CPU that offers ‚Äúinstant access‚Äù but limited.</p>

<p>ARM processor works with the concept of load-store architecture, where there will be three process that you have to go through, for example if you try to add two numbers together, you might do this:</p>

<ul>
  <li>
    <p>Load the two numbers to their respective register somewhere in the memory.</p>
  </li>
  <li>
    <p>Perform the operation and saved the result to a third register.</p>
  </li>
  <li>
    <p>Store the result that we saved earlier in third register into the memory.</p>
  </li>
</ul>

<p>When 64-bit program run in ARM Processor(User-Mode), it has the ability to used:</p>

<ul>
  <li>
    <p>31 general-purpose registers denote as X0-X30 to perform basically anything you want, whereas in 32-bit arm you only have access to 13 registers denote as R0-R12.</p>
  </li>
  <li>
    <p>A Program Counter(PC) that hold the current address of instruction that being executed. In exploit development, this will be our main target to take control of the program. In 32-bit, PC register is equivalent to R15</p>
  </li>
  <li>
    <p>A Link Register(LR) which equivalent as X30 used to stored the return address when function is called. You should try to avoid using this register or your program will go ‚Äúkaboom‚Äù. In 32-bit, LR is equivalent to R14</p>
  </li>
  <li>
    <p>A Stack Pointer(SP) which point to the current top of the stack. In 32-bit, SP is equivalent to R13.</p>
  </li>
</ul>

<h2> Writing Hello World in ARM-64 bit assembly </h2>

<p>Just like the tradition in any programming language, let‚Äôs try to create a assembly program that spit out ‚Äúhello world‚Äù. Put this code in any text editor inside kali linux.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">.text</span>
<span class="nf">.global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>
	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span>
	<span class="nf">ldr</span> <span class="nv">X1</span><span class="p">,</span> <span class="err">=</span><span class="nv">helloworld</span>
	<span class="nf">mov</span> <span class="nv">X2</span><span class="p">,</span> <span class="err">#</span><span class="mi">13</span>
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span>
	<span class="nf">svc</span> <span class="mi">0</span>

	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span><span class="mi">0</span>
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span><span class="err">#</span><span class="mi">93</span>
	<span class="nf">svc</span> <span class="mi">0</span>

<span class="nf">.data</span>
<span class="nl">helloworld:</span> <span class="nf">.ascii</span> <span class="err">"</span><span class="nv">hello</span> <span class="nv">world</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span></code></pre></figure>

<p><b>Note: Please don‚Äôt try to just copy-paste the code, try to typing it one by one.</b></p>

<p>Save the code as ‚Äúhelloworld.s‚Äù (yes! the extension is .s) and let‚Äôs compile the program by using this command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">~# as helloworld.s <span class="nt">-o</span> helloworld.o
~# ld helloworld.o <span class="nt">-o</span> helloworld </code></pre></figure>

<p>You can just run the program by doing this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">~# ./helloworld
hello world!</code></pre></figure>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/arm64_exploit_dev_1/arm_ch1_3.png" alt="SETUP_PREVIEW" /></p>

<p>Let‚Äôs try to understand the code one by one,</p>

<ul>
  <li>In assembly, the instruction goes with this format:</li>
</ul>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">label:</span> <span class="nf">opcode</span> <span class="nv">operands</span> </code></pre></figure>

<p>Where opcode is the command like ‚ÄúMOV‚Äù and ‚ÄúLDR‚Äù, whereas operands is the value or register that we used.</p>

<ul>
  <li>At the top of the source command there is ‚Äú.text‚Äù, this used to defining the section of ‚Äútext‚Äù section that will hold our assembly source code.</li>
</ul>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">.text</span> <span class="o">&lt;</span>
<span class="nf">.global</span> <span class="nv">_start</span></code></pre></figure>

<ul>
  <li>The program entry point is at ‚Äú_start‚Äù, we need to define this as a global symbol by writting ‚Äú.global _start‚Äù so that the linker has access to it.</li>
</ul>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">.text</span> 
<span class="nf">.global</span> <span class="nv">_start</span> <span class="o">&lt;</span>

<span class="nl">_start:</span> <span class="err">&lt;</span></code></pre></figure>

<ul>
  <li>At the first section of the code we try to call write() function in linux that used to print a string, first we need to define the parameter that require for the function. According to linux man page, write require three parameters:</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">write</span><span class="p">(</span><span class="n">fd</span> <span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<p>fd used for file description this tell the whether we want to read(0) or write(1) or error(2). To set the first parameter we assign the value #1 to the register X0 that act as the first parameter.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">_start:</span>
	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span> <span class="o">&lt;</span>
	<span class="nf">ldr</span> <span class="nv">X1</span><span class="p">,</span> <span class="err">=</span><span class="nv">helloworld</span>
	<span class="nf">mov</span> <span class="nv">X2</span><span class="p">,</span> <span class="err">#</span><span class="mi">13</span>
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span>
	<span class="nf">svc</span> <span class="mi">0</span></code></pre></figure>

<p>*buf used to store the address of the content that we want to output, in this case ‚Äúhello world!\n‚Äù which is reference as ‚Äú=helloworld‚Äù, remember we want the address not the value, thus, we use instruction ‚Äúldr‚Äù to load the address of the string to register X1 that act as the second parameter.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">_start:</span>
	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span> 
	<span class="nf">ldr</span> <span class="nv">X1</span><span class="p">,</span> <span class="err">=</span><span class="nv">helloworld</span> <span class="o">&lt;</span>
	<span class="nf">mov</span> <span class="nv">X2</span><span class="p">,</span> <span class="err">#</span><span class="mi">13</span>
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span>
	<span class="nf">svc</span> <span class="mi">0</span>

<span class="nf">.data</span>
<span class="nl">helloworld:</span> <span class="nf">.ascii</span> <span class="err">"</span><span class="nv">hello</span> <span class="nv">world</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span> <span class="o">&lt;</span></code></pre></figure>

<p>size_t count used to store the length of the string, in this case 13, we can assign this value to register X2 that act as the third register using ‚ÄúMOV‚Äù instruction.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">_start:</span>
	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span> 
	<span class="nf">ldr</span> <span class="nv">X1</span><span class="p">,</span> <span class="err">=</span><span class="nv">helloworld</span>
	<span class="nf">mov</span> <span class="nv">X2</span><span class="p">,</span> <span class="err">#</span><span class="mi">13</span> <span class="o">&lt;</span>
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span>
	<span class="nf">svc</span> <span class="mi">0</span></code></pre></figure>

<p>finally, to called the system call of write function by specifying the function number in register X8, which in this case 64. After that we called software interrupt by using instruction ‚Äúsvc 0‚Äù so we can call the function without worrying about the location of the routine in the memory.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nl">_start:</span>
	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span> 
	<span class="nf">ldr</span> <span class="nv">X1</span><span class="p">,</span> <span class="err">=</span><span class="nv">helloworld</span>
	<span class="nf">mov</span> <span class="nv">X2</span><span class="p">,</span> <span class="err">#</span><span class="mi">13</span> 
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span> <span class="err">#</span><span class="mi">64</span> <span class="o">&lt;</span>
	<span class="nf">svc</span> <span class="mi">0</span> <span class="o">&lt;</span></code></pre></figure>

<p>The second section is used to called exit() function so the program can exit flawlessly.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">	<span class="nf">mov</span> <span class="nv">X0</span><span class="p">,</span><span class="mi">0</span>
	<span class="nf">mov</span> <span class="nv">X8</span><span class="p">,</span><span class="err">#</span><span class="mi">93</span>
	<span class="nf">svc</span> <span class="mi">0</span></code></pre></figure>

<h2> Debugging Assembly </h2>

<h2> Compiling and analysing C in ARM </h2>

<p>Okay! now that you have try to do assembly lets try to create and compile the same program but written in C.</p>

:ET